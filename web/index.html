<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta httpEquiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1.00001, viewport-fit=cover" />
    <title>Obra Limpa</title>
    <style>
      #root, body, html {
        width: 100%;
        -webkit-overflow-scrolling: touch;
        margin: 0px;
        padding: 0px;
        min-height: 100%;
      }
      #root {
        flex-shrink: 0;
        flex-basis: auto;
        flex-grow: 1;
        display: flex;
        flex: 1;
      }
      html {
        scroll-behavior: smooth;
        -webkit-text-size-adjust: 100%;
        height: 100%;
      }
      body {
        display: flex;
        overflow-y: auto;
        overscroll-behavior-y: none;
        text-rendering: optimizeLegibility;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        -ms-overflow-style: scrollbar;
      }

      /* Remove completamente o dropdown de rota do Expo Router no rodapé */
      [data-expo-router-root] > div[style*="position: fixed"] {
        display: none !important;
      }

      /* Remove qualquer elemento fixo no rodapé (dropdown de rotas do Expo Router) */
      div[style*="position: fixed"][style*="bottom"] {
        display: none !important;
      }

      /* Remove elementos com classes CSS específicas do Expo Router */
      .css-view-g5y9jx[role="tab"],
      .r-touchAction-1otgn73[role="tab"],
      .r-alignItems-1awozwy[role="tab"],
      .r-flexDirection-18u37iz[role="tab"],
      .r-justifyContent-1777fci[role="tab"],
      .r-padding-1uu6nss[role="tab"] {
        display: none !important;
        visibility: hidden !important;
        width: 0 !important;
        height: 0 !important;
        min-width: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
      }

      /* Remove qualquer elemento que contenha 'admin/chat' no href ou texto */
      a[href*="admin/chat"],
      a[href="/admin/chat"],
      [role="tab"] a[href*="admin/chat"],
      [role="tab"] a[href="/admin/chat"],
      div:has(a[href*="admin/chat"]),
      div:has(a[href="/admin/chat"]) {
        display: none !important;
        visibility: hidden !important;
        width: 0 !important;
        height: 0 !important;
        min-width: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
      }

      /* Remove elementos com ícone de seta para baixo (⏷) */
      *:contains("⏷") {
        display: none !important;
      }

      /* Remove elementos com texto 'admin/chat' */
      *:contains("admin/chat") {
        display: none !important;
      }

      /* Remove especificamente o elemento com as classes CSS do Expo Router */
      .css-view-g5y9jx.r-flex-13awgt0,
      .css-view-g5y9jx.r-touchAction-1otgn73.r-alignItems-1awozwy.r-flexDirection-18u37iz.r-justifyContent-1777fci.r-padding-1uu6nss,
      .css-view-g5y9jx.r-height-h0d30l.r-width-726pan,
      .css-view-g5y9jx.r-alignItems-1awozwy.r-alignSelf-1kihuf0.r-height-1pi2tsx.r-justifyContent-1777fci.r-position-u8s1d.r-width-13qz1uu,
      .css-text-146c3p1.r-backgroundColor-1niwhzg,
      .css-text-146c3p1.r-maxWidth-dnmrzs.r-overflow-1udh08x.r-textOverflow-1udbk01.r-whiteSpace-3s2u2q.r-wordWrap-1iln25a.r-backgroundColor-1niwhzg.r-textAlign-q4m81j.r-lineHeight-135wba7.r-marginInlineStart-1a11zyx.r-fontSize-n6v787.r-marginInlineStart-wizibn {
        display: none !important;
        visibility: hidden !important;
        width: 0 !important;
        height: 0 !important;
        min-width: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
      }
      /* Esconde abas de admin e chat no web para workers */
      [data-testid*="tab-bar"] [aria-label="admin"],
      [data-testid*="tab-bar"] [aria-label="chat"] {
        display: none !important;
      }
      /* Esconde abas de admin e chat no web para workers */
      .css-view-g5y9jx.r-touchAction-1otgn73.r-alignItems-1awozwy.r-flexDirection-18u37iz.r-justifyContent-1777fci.r-padding-1uu6nss {
        display: none !important;
      }

      /* ===== BLOQUEIO COMPLETO DO GOOGLE TRANSLATE ===== */
      /* Remove a barra de tradução do Google que aparece automaticamente */
      #google_translate_element,
      .goog-te-banner-frame,
      .goog-te-menu-frame,
      .goog-te-ftab-frame,
      .goog-te-balloon-frame,
      .goog-te-combo,
      .goog-te-gadget,
      .goog-te-gadget-simple,
      .goog-te-gadget-icon,
      .goog-te-spinner-pos,
      .goog-te-spinner,
      .skiptranslate,
      .VIpgJd-ZVi9od-ORHb-OEVmcd,
      .VIpgJd-ZVi9od-xl07Ob-OEVmcd,
      .VIpgJd-ZVi9od-ORHb,
      .VIpgJd-ZVi9od-xl07Ob,
      .VIpgJd-ZVi9od-aZ2wEe-OEVmcd,
      .VIpgJd-ZVi9od-aZ2wEe,
      .VIpgJd-ZVi9od-l4eHX-hSRGPd,
      .VIpgJd-ZVi9od-l4eHX,
      .VIpgJd-ZVi9od-ORHb-OEVmcd.skiptranslate,
      .VIpgJd-ZVi9od-xl07Ob-OEVmcd.skiptranslate,
      iframe[src*="translate.google"],
      iframe[src*="translate.googleapis"],
      div[id*="google_translate"],
      div[class*="google-translate"],
      div[class*="goog-te"],
      span[class*="goog-te"],
      select[class*="goog-te"],
      .notranslate {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
        width: 0 !important;
        height: 0 !important;
        min-width: 0 !important;
        min-height: 0 !important;
        max-width: 0 !important;
        max-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
        border: none !important;
        position: absolute !important;
        left: -9999px !important;
        top: -9999px !important;
        z-index: -9999 !important;
        pointer-events: none !important;
        overflow: hidden !important;
      }

      /* Remove qualquer iframe do Google Translate */
      iframe[name*="goog"],
      iframe[id*="goog"],
      iframe[src*="translate"] {
        display: none !important;
        visibility: hidden !important;
      }

      /* Remove elementos que contenham texto relacionado ao Google Translate */
      *[title*="Google Translate"],
      *[alt*="Google Translate"],
      *[aria-label*="Google Translate"],
      *[data-translate*="google"] {
        display: none !important;
        visibility: hidden !important;
      }

      /* Força o body a não ter margin-top que pode ser adicionado pelo Google Translate */
      body {
        margin-top: 0 !important;
        padding-top: 0 !important;
      }

      /* Remove qualquer elemento fixo no topo da página */
      body > div:first-child[style*="position: fixed"],
      body > div:first-child[style*="position: absolute"][style*="top: 0"] {
        display: none !important;
      }
    </style>
    <script>
      // ===== BLOQUEIO JAVASCRIPT DO GOOGLE TRANSLATE =====
      // Bloqueia completamente o Google Translate
      (function() {
        // Bloqueia a criação de elementos do Google Translate
        const originalCreateElement = document.createElement;
        document.createElement = function(tagName) {
          const element = originalCreateElement.call(this, tagName);

          // Bloqueia iframes do Google Translate
          if (tagName.toLowerCase() === 'iframe') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if (name === 'src' && (value.includes('translate.google') || value.includes('translate.googleapis'))) {
                return; // Não define o src
              }
              return originalSetAttribute.call(this, name, value);
            };
          }

          // Bloqueia divs do Google Translate
          if (tagName.toLowerCase() === 'div') {
            const originalSetAttribute = element.setAttribute;
            element.setAttribute = function(name, value) {
              if ((name === 'id' || name === 'class') && value.includes('google_translate')) {
                return; // Não define o atributo
              }
              return originalSetAttribute.call(this, name, value);
            };
          }

          return element;
        };

        // Bloqueia scripts do Google Translate
        const originalAppendChild = Node.prototype.appendChild;
        Node.prototype.appendChild = function(child) {
          if (child.tagName === 'SCRIPT' && child.src &&
              (child.src.includes('translate.google') || child.src.includes('translate.googleapis'))) {
            return child; // Não adiciona o script
          }
          if (child.tagName === 'IFRAME' && child.src &&
              (child.src.includes('translate.google') || child.src.includes('translate.googleapis'))) {
            return child; // Não adiciona o iframe
          }
          return originalAppendChild.call(this, child);
        };

        // Remove elementos do Google Translate que já existem
        function removeGoogleTranslateElements() {
          const selectors = [
            '#google_translate_element',
            '.goog-te-banner-frame',
            '.goog-te-menu-frame',
            '.goog-te-ftab-frame',
            '.goog-te-balloon-frame',
            '.goog-te-combo',
            '.goog-te-gadget',
            '.goog-te-gadget-simple',
            '.goog-te-gadget-icon',
            '.goog-te-spinner-pos',
            '.goog-te-spinner',
            '.skiptranslate',
            'iframe[src*="translate.google"]',
            'iframe[src*="translate.googleapis"]',
            'div[id*="google_translate"]',
            'div[class*="google-translate"]',
            'div[class*="goog-te"]',
            'span[class*="goog-te"]',
            'select[class*="goog-te"]'
          ];

          selectors.forEach(selector => {
            try {
              document.querySelectorAll(selector).forEach(el => {
                if (el && el.parentNode) {
                  el.parentNode.removeChild(el);
                }
              });
            } catch (e) {
              // Ignora erros
            }
          });

          // Remove margin-top do body que pode ser adicionado pelo Google Translate
          if (document.body) {
            document.body.style.marginTop = '0px';
            document.body.style.paddingTop = '0px';
          }
        }

        // Executa a remoção periodicamente
        setInterval(removeGoogleTranslateElements, 100);

        // Executa quando o DOM estiver pronto
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', removeGoogleTranslateElements);
        } else {
          removeGoogleTranslateElements();
        }

        // Executa quando a página carregar
        window.addEventListener('load', removeGoogleTranslateElements);

        // COMENTADO TEMPORARIAMENTE - PODE ESTAR BLOQUEANDO GOOGLE MAPS
        // Bloqueia variáveis globais do Google Translate
        // Object.defineProperty(window, 'google', {
        //   get: function() { return undefined; },
        //   set: function() { return false; },
        //   configurable: false
        // });

        Object.defineProperty(window, 'googleTranslateElementInit', {
          get: function() { return undefined; },
          set: function() { return false; },
          configurable: false
        });

        console.log('[Obra Limpa] Google Translate bloqueado completamente');
      })();
    </script>
    <script>
      // Configuração ultra-robusta para tornar event listeners passivos por padrão
      // Isso resolve o aviso: "Added non-passive event listener to a scroll-blocking 'wheel' event"
      (function() {
        if (typeof window !== 'undefined') {
          // Lista de eventos que devem ser passivos por padrão
          const passiveEvents = ['wheel', 'mousewheel', 'touchstart', 'touchmove', 'touchend', 'scroll'];

          // Função para forçar passive em options
          function forcePassiveOptions(type, options) {
            if (passiveEvents.includes(type)) {
              if (typeof options === 'boolean') {
                return { capture: options, passive: true };
              } else if (typeof options === 'object' && options !== null) {
                return { ...options, passive: true };
              } else {
                return { passive: true };
              }
            }
            return options;
          }

          // Intercepta addEventListener em EventTarget (mais agressivo)
          if (window.EventTarget && EventTarget.prototype.addEventListener) {
            const originalAddEventListener = EventTarget.prototype.addEventListener;

            EventTarget.prototype.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);

              // Log para debug específico do VirtualizedList
              if (type === 'wheel' && typeof listener === 'function') {
                const stack = new Error().stack;
                if (stack && stack.includes('VirtualizedList')) {
                  console.log('[Obra Limpa] Interceptando wheel event do VirtualizedList - forçando passive: true');
                }
              }

              return originalAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Intercepta addEventListener em HTMLElement especificamente
          if (window.HTMLElement && HTMLElement.prototype.addEventListener) {
            const originalHTMLAddEventListener = HTMLElement.prototype.addEventListener;

            HTMLElement.prototype.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalHTMLAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Intercepta addEventListener em Document
          if (window.Document && Document.prototype.addEventListener) {
            const originalDocAddEventListener = Document.prototype.addEventListener;

            Document.prototype.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalDocAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Intercepta addEventListener em Window
          if (window.addEventListener) {
            const originalWinAddEventListener = window.addEventListener;

            window.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalWinAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Intercepta addEventListener em Element
          if (window.Element && Element.prototype.addEventListener) {
            const originalElemAddEventListener = Element.prototype.addEventListener;

            Element.prototype.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalElemAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Interceptação específica para Node (caso o VirtualizedList use)
          if (window.Node && Node.prototype.addEventListener) {
            const originalNodeAddEventListener = Node.prototype.addEventListener;

            Node.prototype.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalNodeAddEventListener.call(this, type, listener, newOptions);
            };
          }

          // Patch adicional para capturar chamadas diretas de addEventListener
          const originalAddEventListener = window.addEventListener;
          if (originalAddEventListener) {
            window.addEventListener = function(type, listener, options) {
              const newOptions = forcePassiveOptions(type, options);
              return originalAddEventListener.call(this, type, listener, newOptions);
            };
          }

          console.log('[Obra Limpa] Event listeners configurados como passivos (versão ultra-robusta)');
        }
      })();

      // Script para remover o rodapé de navegação do Expo Router
      function removeAdminChatLink() {
        try {
          // Remove todos os links para /admin/chat
          document.querySelectorAll('a[href="/admin/chat"]').forEach(el => {
            if (el.parentElement) el.parentElement.removeChild(el);
          });

          // Remove qualquer div que contenha esse link
          document.querySelectorAll('div').forEach(div => {
            if (div.innerHTML && div.innerHTML.includes('/admin/chat')) {
              div.style.display = 'none';
              div.style.visibility = 'hidden';
              div.style.width = '0';
              div.style.height = '0';
              div.style.position = 'absolute';
              div.style.left = '-9999px';
            }
          });

          // Remove elementos com classes específicas do Expo Router
          document.querySelectorAll('.css-view-g5y9jx').forEach(el => {
            if (el.innerHTML && el.innerHTML.includes('admin/chat')) {
              el.style.display = 'none';
              el.style.visibility = 'hidden';
            }
          });

          // Remove TODOS os elementos com role="tab" (rodapé completo)
          document.querySelectorAll('[role="tab"]').forEach(el => {
            el.style.display = 'none';
            el.style.visibility = 'hidden';
            el.style.width = '0';
            el.style.height = '0';
          });

          // Remove elementos com o ícone ⏷
          document.querySelectorAll('*').forEach(el => {
            if (el.textContent && el.textContent.includes('⏷')) {
              el.style.display = 'none';
              el.style.visibility = 'hidden';
            }
          });

        } catch (error) {
          console.log('Erro ao remover elemento:', error);
        }
      }

      // Executa quando o DOM estiver pronto
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function() {
          removeAdminChatLink();
          setInterval(removeAdminChatLink, 50);
        });
      } else {
        removeAdminChatLink();
        setInterval(removeAdminChatLink, 50);
      }

      // Executa também quando a página carregar completamente
      window.addEventListener('load', function() {
        removeAdminChatLink();
        setInterval(removeAdminChatLink, 50);
      });

      setInterval(() => {
        document.querySelectorAll('a[role="tab"]').forEach(el => {
          if (el.textContent.trim().toLowerCase() === 'chat' || el.textContent.trim().toLowerCase() === 'admin') {
            el.style.display = 'none';
          }
        });
      }, 100);
    </script>

    <!-- Script para garantir que o elemento root esteja disponível -->
    <script>
      // Garantir que o elemento root existe antes do React tentar renderizar
      document.addEventListener('DOMContentLoaded', function() {
        if (!document.getElementById('root')) {
          const rootDiv = document.createElement('div');
          rootDiv.id = 'root';
          document.body.appendChild(rootDiv);
        }
      });

      // Fallback para casos onde o DOMContentLoaded já foi disparado
      if (document.readyState === 'loading') {
        // DOM ainda está carregando
      } else {
        // DOM já carregou
        if (!document.getElementById('root')) {
          const rootDiv = document.createElement('div');
          rootDiv.id = 'root';
          document.body.appendChild(rootDiv);
        }
      }
    </script>

    <!-- Google Places API -->
    <script>
      // Verificar se o Google Maps já foi carregado para evitar duplicação
      if (window.google && window.google.maps && window.google.maps.places) {
        console.log('[Obra Limpa] Google Maps API já carregada, pulando carregamento duplicado');
      } else {
        // Callback para quando a Google Maps API carregar
        function initGoogleMaps() {
          console.log('[Obra Limpa] 🎯 Google Maps API carregada com sucesso!');
          console.log('[Obra Limpa] window.google:', !!window.google);
          console.log('[Obra Limpa] window.google.maps:', !!window.google?.maps);
          console.log('[Obra Limpa] window.google.maps.places:', !!window.google?.maps?.places);

          // Validar se a API está realmente funcionando
          if (window.google && window.google.maps && window.google.maps.places) {
            console.log('[Obra Limpa] ✅ Google Maps Places API totalmente carregada e funcional');

            // Teste básico do AutocompleteService
            try {
              const service = new window.google.maps.places.AutocompleteService();
              console.log('[Obra Limpa] ✅ AutocompleteService criado com sucesso');
            } catch (error) {
              console.error('[Obra Limpa] ❌ Erro ao criar AutocompleteService:', error);
            }
          } else {
            console.error('[Obra Limpa] ❌ Google Maps API carregou mas Places não está disponível');
          }

          // Disparar evento customizado para notificar que a API está pronta
          window.dispatchEvent(new CustomEvent('googleMapsApiLoaded', {
            detail: {
              ready: !!(window.google && window.google.maps && window.google.maps.places)
            }
          }));
        }

        // Callback para lidar com erros de carregamento
        function handleGoogleMapsError() {
          console.error('[Obra Limpa] ❌ ERRO CRÍTICO: Falha ao carregar Google Maps API');
          console.error('[Obra Limpa] URL tentada: https://maps.googleapis.com/maps/api/js?key=AIzaSyBer6x1O4RAlrkHw8HYhh-lRgrbKlnocEA&libraries=places&language=pt&region=BR&callback=initGoogleMaps');
          console.error('[Obra Limpa] Possíveis causas:');
          console.error('[Obra Limpa] 1. API Key inválida ou sem permissões');
          console.error('[Obra Limpa] 2. Cota da API excedida');
          console.error('[Obra Limpa] 3. Problemas de rede ou bloqueio de domínio');
          console.error('[Obra Limpa] 4. Configuração incorreta no Google Cloud Console');

          // Disparar evento de erro
          window.dispatchEvent(new CustomEvent('googleMapsApiError'));
        }

        // Monitoramento avançado do carregamento
        console.log('[Obra Limpa] 🚀 INICIANDO carregamento da Google Maps API...');
        console.log('[Obra Limpa] 🔑 API Key sendo usada: AIzaSyBer6x1O4RAlrkHw8HYhh-lRgrbKlnocEA');
        console.log('[Obra Limpa] 🌐 URL completa:', 'https://maps.googleapis.com/maps/api/js?key=AIzaSyBer6x1O4RAlrkHw8HYhh-lRgrbKlnocEA&libraries=places&language=pt&region=BR&callback=initGoogleMaps');

        // Verificar se já existe google no window antes do carregamento
        console.log('[Obra Limpa] 🔍 Estado inicial do window.google:', !!window.google);

        // Monitor de timeout personalizado
        const loadingTimeout = setTimeout(() => {
          if (!window.google || !window.google.maps || !window.google.maps.places) {
            console.error('[Obra Limpa] ⏰ TIMEOUT: Google Maps API não carregou em 15 segundos');
            console.error('[Obra Limpa] 📊 Estado atual:');
            console.error('[Obra Limpa]   - window.google:', !!window.google);
            console.error('[Obra Limpa]   - window.google.maps:', !!(window.google && window.google.maps));
            console.error('[Obra Limpa]   - window.google.maps.places:', !!(window.google && window.google.maps && window.google.maps.places));
            handleGoogleMapsError();
          }
        }, 15000);

        // Limpar timeout se carregou com sucesso
        window.addEventListener('googleMapsApiLoaded', () => {
          clearTimeout(loadingTimeout);
          console.log('[Obra Limpa] ✅ Timeout cancelado - API carregou com sucesso');
        });
      }
    </script>
    <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBer6x1O4RAlrkHw8HYhh-lRgrbKlnocEA&libraries=places&language=pt&region=BR&callback=initGoogleMaps"
      onerror="handleGoogleMapsError()">
    </script>
  </head>
  <body>
    <div id="root"></div>

    <!-- Script adicional para verificar se o root existe após o carregamento -->
    <script>
      window.addEventListener('load', function() {
        const rootElement = document.getElementById('root');
        if (!rootElement) {
          console.error('Elemento root não encontrado, criando um novo...');
          const newRoot = document.createElement('div');
          newRoot.id = 'root';
          document.body.appendChild(newRoot);
        } else {
          console.log('Elemento root encontrado com sucesso');
        }
      });
    </script>
  </body>
</html>
